# Vectors

<Lead>
The word "vector" sounds intimidating. It isn't. A vector is just a list of numbers.
But this simple idea turns out to be the key to understanding what neurons actually do — and why stacking them in layers works at all.
</Lead>

## Describing Things with Vectors

You already use lists of numbers to describe things. Your position on the planet is two numbers: (latitude, longitude). A color on screen is three numbers: (red, green, blue). An RPG character has stats like (strength, magic, speed, defense). Each of these is a **vector** — a list of numbers that together describe something.

We can use the same idea to describe almost anything. Take animals: rate each one from 0 to 1 on properties like big, scary, hairy, cuddly, fast, and fat, and you get a vector that captures what makes that animal distinctive.

<VectorPropertyExplorerWidget>
Switch between tabs to see different kinds of vectors. Click two items to compare their vectors side by side — green bars mean the values are similar, red bars mean they're different. Which pair is the most similar? Try all four tabs to see how the same idea applies to completely different things.
</VectorPropertyExplorerWidget>

The number of measurements is the vector's **dimension** — our animal vectors have 6 dimensions, one per property. More dimensions let you make finer distinctions. With just "big" and "scary," a bear and a dog might look similar. Add "cuddly" and they separate out.

Notice something important: the vector captures what we *chose* to measure. If we'd picked different properties, the same items would get different vectors. **The choice of dimensions determines what the vector can distinguish.**

<KeyInsight>
**A vector is a compact description.** It's a list of numbers that together describe something. More dimensions mean finer distinctions. Vectors can describe positions, colors, characters, animals, foods — anything you can capture with numbers.
</KeyInsight>

## Magnitude and Unit Vectors

You can see in the 2D Line tab above that a 2D line has a length. It turns out that *all* vectors have a length, not just 2D ones. We compute the length of a vector — which we call its **magnitude** — using the same Pythagorean rule that we use to compute the length of a line: square all the dimensions, add them together, and take the square root.

One particularly important kind of vector is a **unit vector** — a vector whose magnitude is 1. The animal, food, and instrument vectors above are all unit vectors. You can think of a unit vector as the "standard size" for a vector, just as 1 is the standard size for a number.

Why does this matter? Scaling every vector to magnitude 1 preserves the *proportions* between dimensions — a bear is still scarier than it is fast — but makes every vector the same size. This turns out to be exactly what we need when we want to measure how similar two things are.

Any vector can be multiplied by a number to make it longer or shorter. A unit vector multiplied by a magnitude gives a vector that points in the same direction but has a different length.

<UnitVectorExplorerWidget>
On the **2D Space** tab, drag the unit vector around the circle and adjust the magnitude slider. On the **Custom Animal** tab, design your own animal — notice how adjusting one property automatically scales the others to keep the magnitude at 1. On the **Amplified Animal** tab, pick an animal and see what happens when you multiply its unit vector by different magnitudes.
</UnitVectorExplorerWidget>

## Cosine Similarity

Now that we have unit vectors — vectors that are all the same size — we can measure **how similar** two things are. There's a beautifully simple operation called **cosine similarity**. You multiply each matching pair of numbers, then add up all the results:

**similarity = (a₁ × b₁) + (a₂ × b₂) + … + (aₙ × bₙ)**

The result is a single number:
- **1** means they're identical
- **0** means they have nothing in common
- **−1** means they're completely opposite

This works for unit vectors, because they have been scaled so that their cosine similarity with themself is one. See the next section to find out what happens if you do the same math with vectors that aren't unit vectors.

<DotProductComparisonWidget>
Pick two items and compare their similarity. The multiply column shows what happens at each dimension — when both items score high on the same property, that contributes a lot to the total. When one scores high and the other low, it contributes almost nothing. Try the **2D Arrows** tab to see how similarity relates to the angle between vectors.
</DotProductComparisonWidget>

Why does multiply-and-add measure similarity? Look at the per-dimension math. When both vectors score high on the same property, multiplying those gives a big number — that shared trait contributes a lot to the total. But if one scores high and the other low, multiplying gives almost nothing. Add up all these products, and you get a total that's high when the vectors agree and low when they don't.

## The Dot Product

Cosine similarity only works on unit vectors. The **dot product** is a more general version of the same operation — the math is identical (multiply matching pairs, add them up), but it works on vectors of any size:

**a · b = (a₁ × b₁) + (a₂ × b₂) + … + (aₙ × bₙ)**

Like cosine similarity, the dot product measures how similar two vectors are — it's bigger when they point the same way and negative when they point in opposite directions. But it also measures how *big* each vector is — the dot product gets larger when either vector has a greater magnitude. When both vectors are unit vectors, the dot product *is* cosine similarity.

The best way to understand this is to play with it:

<DotProduct2DWidget>
Drag the two vectors around. The dot product gets big when both vectors are long and point the same way. It's zero when they're at right angles. It goes negative when they point in opposite directions. Try making one vector very short — the dot product shrinks even if they point the same way.
</DotProduct2DWidget>

<KeyInsight>
**The dot product measures similarity and size together.** It gets bigger when the vectors are more similar, and bigger when the vectors have greater magnitudes. Cosine similarity is a dot product between unit vectors, giving a pure similarity score. The dot product is the foundation of how neural networks process information.
</KeyInsight>

## A Neuron Is (Mostly) a Dot Product

Here's the connection that ties everything together. Remember from the previous chapter that a neuron computes a **weighted sum** of its inputs, adds a bias, then applies an activation function. That weighted sum is a dot product — the neuron has a **weight vector** and receives an **input vector**:

<Callout>
**output = activation( w · x + bias )**

where **w** = (w₁, w₂, …, wₙ) is the weight vector and **x** = (x₁, x₂, …, xₙ) is the input vector.
</Callout>

The neuron is asking **"is this input what I'm looking for?"**.

* **The direction** of the weight vector (it's unit vector) says what kind of thing the neuron is looking for.
* **The magnitude** of the weight vector says how much of what it's looking for the neuron needs to see in order to get excited.
* **The bias** says how excited it is if it hasn't seen anything at all.

The best way to understand this is to play with it. Try the **Animals** tab and set the weight to "Bear" — now you have a bear detector! Feed it different animals as input and watch the output. A dog gets a high score because it shares many bear-like properties. A mouse scores low. You can do the same with any category — set the weight to "Pizza" on the **Foods** tab and you have a pizza detector.

<NeuronDotProductWidget>
On the **2D Vectors** tab, drag the weight and input vectors to see how the angle between them affects the output.

On the other tabs, try matching different animals, foods, or instruments as weights and inputs. What happens when you slide the weight magnitude up or down? What about the bias?
</NeuronDotProductWidget>

<KeyInsight>
**A neuron is a direction detector.** It computes the dot product of its input vector with its weight vector, adds a bias to shift the threshold, and squashes the result through an activation function. The weights define a direction in input space, and the neuron fires when the input points that way.
</KeyInsight>

## What's Next

A vector is just a list of numbers — but it's a remarkably powerful idea. We've seen how cosine similarity measures how alike two vectors are, how the dot product generalizes multiplication to multiple dimensions, and how a neuron uses the dot product to detect patterns in its input.

But so far we've been describing things with *hand-picked* properties — big, scary, hairy. That works for animals, because animals are one kind of thing and we can choose sensible properties for them. But what about words? "Dog" and "democracy" and "purple" and "running" — there's no single set of properties that makes sense for all of them. "How scary is the color blue?" isn't a meaningful question.

In the next chapter, we'll see how AI solves this problem: instead of choosing dimensions by hand, it *learns* vectors where similar words end up nearby and directions encode meaningful relationships — all without any human labeling.

<TryItInPyTorch notebook="vectors">
Create vectors in PyTorch, compute dot products and cosine similarity, and build a neuron as a dot product.
</TryItInPyTorch>
