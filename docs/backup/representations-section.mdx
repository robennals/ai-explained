## Not All Representations Are Equal

Here's the crucial connection: **the way you represent something determines whether you can optimize it**.

Consider a simple function: "multiply by some number, then add another number." You could write this as text — say, `times four plus two` — or you could represent the same function with two sliders, one for the multiplier and one for the offset.

Both representations describe the exact same function. But try to *change* it to match a target, and the difference is night and day.

**Text**: To change "four" to "two," you have to delete characters and retype. There's no "halfway" between the words "four" and "two." Most mid-edit states (`times fo plus two`, `times tw plus two`) don't even parse. Every edit is a big, unpredictable jump.

**Sliders**: Drag the multiplier from 4.0 smoothly down to 2.0. At every intermediate value — 3.7, 3.2, 2.5 — the function is valid and you can see whether you're getting closer. Small changes produce small, predictable effects.

<ModelComparisonWidget>
Try matching the dashed target line on both sides. On the slider side, just drag — watch the line glide smoothly into place. On the text side, try editing "times four plus two" into "times 2 minus 3." Notice how most intermediate edits break the parser entirely. You can get there eventually, but there's no smooth path — just discrete jumps between valid states.
</ModelComparisonWidget>
